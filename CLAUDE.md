# Lattice - Swift ORM with Sync

## Overview
Lattice is a Swift-based Object-Relational Mapping (ORM) library built on SQLite with built-in sync capabilities. It uses Swift macros for compile-time code generation and provides a Realm-like API.

**Current Architecture**: Swift frontend with C++ backend (LatticeCpp) for core database operations.

## Project Structure

```
Lattice/
‚îú‚îÄ‚îÄ Sources/
‚îÇ   ‚îú‚îÄ‚îÄ Lattice/              # Swift ORM API (delegates to C++ backend)
‚îÇ   ‚îú‚îÄ‚îÄ LatticeMacros/        # Swift macro implementations (@Model, @Property, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ LatticeServerKit/     # Server-side sync infrastructure
‚îú‚îÄ‚îÄ Tests/
‚îÇ   ‚îî‚îÄ‚îÄ LatticeTests/         # Unit tests
‚îî‚îÄ‚îÄ Package.swift             # References LatticeCpp as local dependency
```

**Related**: LatticeCpp at `/Users/jason/Documents/LatticeCpp/` - Core C++ implementation

## Key Architecture Decisions

### 1. **C++ Backend Integration**
- Core database operations delegated to `LatticeCpp` via Swift-C++ interop
- `swift_lattice_ref` wrapper uses `SWIFT_SHARED_REFERENCE` for memory management
- `swift_dynamic_object` for type-erased model storage from Swift
- `managed<swift_dynamic_object>` (aliased as `ManagedModel`) for managed objects
- Schemas passed from Swift to C++ at init time for table creation

### 2. **Struct-Based Design (Not Actor)**
- `Lattice` is a **struct**, not an actor
- Wraps `swift_lattice_ref` which holds `shared_ptr<swift_lattice>`
- Connection caching by config path in C++ layer
- Isolation tracking is for **notification delivery**, not execution context

### 3. **Macro-Based Property System**
- `@Model` macro generates schema metadata and property accessors
- Properties use `Accessor<T>` wrappers for change tracking
- `CxxManaged` protocol for Swift ‚Üî C++ value conversion
- All macros in `Sources/LatticeMacros/LatticeMacros.swift`

### 4. **Schema Management**
- Schemas built in Swift via `Model.cxxPropertyDescriptor()`
- Passed to C++ as `SchemaVector` at `Lattice` init time
- Tables created by C++ `create_model_table_public()`
- `id` and `globalId` filtered out in Swift (auto-added by C++)
- `discoverAllTypes(from:)` recursively finds linked Model types

### 5. **Results (Live Queries)**
- `Results<T>` always fetches fresh data from database
- `endIndex` calls C++ `count()` method
- Subscript/iteration calls C++ `objects()` with limit/offset
- No caching - queries are "live"

### 6. **Reserved Property Names**
- `id` and `globalId` are reserved (auto-generated by Lattice)
- Macro validation prevents users from using these names
- Filtered out in `cxxPropertyDescriptor()` to avoid duplicate columns

## Current State

### Completed Features
- ‚úÖ Basic CRUD operations via C++ backend
- ‚úÖ Query DSL with type-safe predicates
- ‚úÖ Relationships (links, link lists)
- ‚úÖ Embedded models
- ‚úÖ Observable results
- ‚úÖ Automatic schema discovery
- ‚úÖ Schema passing to C++ at init
- ‚úÖ Table creation in C++ layer
- ‚úÖ `test_Basic` passing

### In Progress
- üîÑ `Results` queries (count returns 0 for filtered results)
- üîÑ WHERE clause generation for Results

### Pending Work
- ‚è≥ Fix `testLattice_ResultsQuery` - count returning 0
- ‚è≥ AuditLog compaction (reduce sync payload size)
- ‚è≥ Accessor init for non-optional EmbeddedModel/LatticeEnum

## Swift-C++ Interop

### Key Types
```
Swift                          C++
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                          ‚îÄ‚îÄ‚îÄ
Lattice                   ‚Üí    swift_lattice_ref (wrapper)
                          ‚Üí    swift_lattice (inherits lattice_db)
Model (protocol)          ‚Üí    swift_dynamic_object
ManagedModel              ‚Üí    managed<swift_dynamic_object>
lattice.SchemaVector      ‚Üí    std::vector<swift_schema_entry>
lattice.SwiftSchema       ‚Üí    std::unordered_map<string, property_descriptor>
```

### Memory Management
- `swift_lattice_ref` uses `SWIFT_SHARED_REFERENCE` with retain/release
- Internal `shared_ptr<swift_lattice>` cached by config path
- `ref_count_` starts at 0 (Swift calls retain on creation)

## Testing

Run tests:
```bash
swift test                              # All tests
swift test --filter test_Basic          # Specific test
swift test --filter testLattice_ResultsQuery
```

### Test Utilities
- `testLattice(path:types...)` - Creates temporary database with fresh schema
- Always use temporary DB in tests to avoid schema conflicts

## Important Notes

### Database Schema
- Tables created by C++ `create_model_table()` at init
- Every table gets `id INTEGER PRIMARY KEY` and `globalId TEXT UNIQUE`
- Audit triggers created for sync/observation
- WAL mode for concurrent access

### Isolation & Threading
- Isolation captured via `isolated (any Actor)? = #isolation` parameter
- Used for dispatching observer notifications to correct context

### Sync Protocol
- Client-side: `AuditLog` tracks changes, uploads via `Synchronizer`
- Server-side: `LatticeServerKit` receives changes, broadcasts to other clients
- Conflict resolution: Last-write-wins (timestamp-based)

## Common Patterns

### Defining a Model
```swift
@Model
public class Trip {
    public var name: String
    public var days: Int
    public var destinations: List<Destination>

    init(name: String, days: Int) {
        self.name = name
        self.days = days
    }
}
```

### Using Lattice
```swift
let lattice = try Lattice(Trip.self)  // Auto-discovers linked types

let trip = Trip(name: "Costa Rica", days: 10)
lattice.add(trip)

let trips = lattice.objects(Trip.self)
for trip in trips {
    print(trip.name)
}
```

### Observing Changes
```swift
let results = lattice.objects(Trip.self)
let token = results.observe { change in
    // Called on specified isolation
}
```
