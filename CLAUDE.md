# Lattice - Swift ORM with Sync

## Overview
Lattice is a Swift-based Object-Relational Mapping (ORM) library built on SQLite with built-in sync capabilities. It uses Swift macros for compile-time code generation and provides a Realm-like API.

**Current Architecture**: Swift frontend with C++ backend (LatticeCpp) for core database operations.

## Project Structure

```
Lattice/
├── Sources/
│   ├── Lattice/              # Swift ORM API (delegates to C++ backend)
│   ├── LatticeMacros/        # Swift macro implementations (@Model, @Property, etc.)
│   └── LatticeServerKit/     # Server-side sync infrastructure
├── Tests/
│   └── LatticeTests/         # Unit tests
└── Package.swift             # References LatticeCpp as local dependency
```

**Related**: LatticeCpp at `/Users/jason/Documents/LatticeCpp/` - Core C++ implementation

## Key Architecture Decisions

### 1. **C++ Backend Integration**
- Core database operations delegated to `LatticeCpp` via Swift-C++ interop
- `swift_lattice_ref` wrapper uses `SWIFT_SHARED_REFERENCE` for memory management
- `swift_dynamic_object` for type-erased model storage from Swift
- `managed<swift_dynamic_object>` (aliased as `ManagedModel`) for managed objects
- Schemas passed from Swift to C++ at init time for table creation

### 2. **Struct-Based Design (Not Actor)**
- `Lattice` is a **struct**, not an actor
- Wraps `swift_lattice_ref` which holds `shared_ptr<swift_lattice>`
- Connection caching by config path in C++ layer
- Isolation tracking is for **notification delivery**, not execution context

### 3. **Macro-Based Property System**
- `@Model` macro generates schema metadata and property accessors
- Properties use `Accessor<T>` wrappers for change tracking
- `CxxManaged` protocol for Swift ↔ C++ value conversion
- All macros in `Sources/LatticeMacros/LatticeMacros.swift`

### 4. **Schema Management**
- Schemas built in Swift via `Model.cxxPropertyDescriptor()`
- Passed to C++ as `SchemaVector` at `Lattice` init time
- Tables created by C++ `create_model_table_public()`
- `id` and `globalId` filtered out in Swift (auto-added by C++)
- `discoverAllTypes(from:)` recursively finds linked Model types

### 5. **Results (Live Queries)**
- `Results<T>` always fetches fresh data from database
- `endIndex` calls C++ `count()` method
- Subscript/iteration calls C++ `objects()` with limit/offset
- No caching - queries are "live"

### 6. **Reserved Property Names**
- `id` and `globalId` are reserved (auto-generated by Lattice)
- Macro validation prevents users from using these names
- Filtered out in `cxxPropertyDescriptor()` to avoid duplicate columns

### 7. **VirtualModel (Polymorphic Queries)**
- `VirtualModel` protocol enables querying across multiple model types
- Models conforming to a shared protocol can be queried together
- Uses UNION ALL queries under the hood with optimized pagination
- Type-safe: `lattice.objects(POI.self)` returns `VirtualResults<POI>`
- Results hydrate back to concrete types (Restaurant, Museum, etc.)
- Implementation uses variadic generics with compile-time type building
- Key files: `VirtualModel.swift`, `Schema` struct in `Lattice.swift`

### 8. **Database Attachment**
- `lattice.attach(lattice:)` attaches another database file
- Uses SQLite's `ATTACH DATABASE` with automatic alias generation
- Creates TEMP VIEWs to hide the alias prefix for transparent querying
- Attached tables participate in VirtualModel/polymorphic queries
- Both read and write connections are attached
- Implementation in C++: `swift_lattice::attach()`

### 9. **Vector Search**
- Built on sqlite-vec extension for ANN (Approximate Nearest Neighbor) search
- Each Vector property gets a vec0 virtual table: `_{Table}_{column}_vec`
- Triggers auto-sync vectors from main table to vec0
- Supports L2 (Euclidean), Cosine, and L1 (Manhattan) distance metrics
- `Results.nearest(to:on:limit:distance:)` API for similarity search
- Federated vector search for VirtualModel queries (queries each vec0, merges results)

## Current State

### Completed Features
- ✅ Basic CRUD operations via C++ backend
- ✅ Query DSL with type-safe predicates
- ✅ Relationships (links, link lists)
- ✅ Embedded models
- ✅ Observable results
- ✅ Automatic schema discovery
- ✅ Schema passing to C++ at init
- ✅ Table creation in C++ layer
- ✅ Vector search with sqlite-vec
- ✅ VirtualModel / Polymorphic queries
- ✅ Database attachment (ATTACH DATABASE)
- ✅ UNION queries with optimized pagination
- ✅ Federated vector search across VirtualModel types
- ✅ `test_Basic` passing
- ✅ `test_Attach` passing

### Pending Work
- ⏳ AuditLog compaction (reduce sync payload size)
- ⏳ Accessor init for non-optional EmbeddedModel/LatticeEnum

## Swift-C++ Interop

### Key Types
```
Swift                          C++
─────                          ───
Lattice                   →    swift_lattice_ref (wrapper)
                          →    swift_lattice (inherits lattice_db)
Model (protocol)          →    swift_dynamic_object
ManagedModel              →    managed<swift_dynamic_object>
lattice.SchemaVector      →    std::vector<swift_schema_entry>
lattice.SwiftSchema       →    std::unordered_map<string, property_descriptor>
```

### Memory Management
- `swift_lattice_ref` uses `SWIFT_SHARED_REFERENCE` with retain/release
- Internal `shared_ptr<swift_lattice>` cached by config path
- `ref_count_` starts at 0 (Swift calls retain on creation)

### Union Query Implementation
```cpp
// C++ generates optimized UNION ALL with pagination
query_union_rows(table_names, where_clause, order_by, limit, offset)

// Generates SQL like:
SELECT * FROM (
    SELECT * FROM (SELECT 'Restaurant' AS _type, * FROM Restaurant
                   WHERE ... ORDER BY name LIMIT 30)  -- inner_limit = offset + limit
    UNION ALL
    SELECT * FROM (SELECT 'Museum' AS _type, * FROM Museum
                   WHERE ... ORDER BY name LIMIT 30)
)
ORDER BY name LIMIT 10 OFFSET 20
```

### Database Attachment (C++)
```cpp
void swift_lattice::attach(swift_lattice& other) {
    // ATTACH DATABASE 'path' AS "alias"
    // Create TEMP VIEWs for each table to hide alias prefix
    // Attaches to both read and write connections
}
```

## Testing

Run tests:
```bash
swift test                              # All tests
swift test --filter test_Basic          # Specific test
swift test --filter testLattice_ResultsQuery
```

### Test Utilities
- `testLattice(path:types...)` - Creates temporary database with fresh schema
- Always use temporary DB in tests to avoid schema conflicts

## Important Notes

### Database Schema
- Tables created by C++ `create_model_table()` at init
- Every table gets `id INTEGER PRIMARY KEY` and `globalId TEXT UNIQUE`
- Audit triggers created for sync/observation
- WAL mode for concurrent access

### Isolation & Threading
- Isolation captured via `isolated (any Actor)? = #isolation` parameter
- Used for dispatching observer notifications to correct context

### Sync Protocol
- Client-side: `AuditLog` tracks changes, uploads via `Synchronizer`
- Server-side: `LatticeServerKit` receives changes, broadcasts to other clients
- Conflict resolution: Last-write-wins (timestamp-based)

## Common Patterns

### Defining a Model
```swift
@Model
public class Trip {
    public var name: String
    public var days: Int
    public var destinations: List<Destination>

    init(name: String, days: Int) {
        self.name = name
        self.days = days
    }
}
```

### Using Lattice
```swift
let lattice = try Lattice(Trip.self)  // Auto-discovers linked types

let trip = Trip(name: "Costa Rica", days: 10)
lattice.add(trip)

let trips = lattice.objects(Trip.self)
for trip in trips {
    print(trip.name)
}
```

### Observing Changes
```swift
let results = lattice.objects(Trip.self)
let token = results.observe { change in
    // Called on specified isolation
}
```

### Polymorphic Queries (VirtualModel)
```swift
// Define protocol extending VirtualModel
protocol POI: VirtualModel {
    var name: String { get }
    var country: String { get }
}

@Model class Restaurant: POI { ... }
@Model class Museum: POI { ... }

// Query across all conforming types
let allPOIs = lattice.objects(POI.self)
let frenchPOIs = lattice.objects(POI.self).where { $0.country == "France" }

// Cast back to concrete type
if let museum = frenchPOIs.first as? Museum { ... }
```

### Database Attachment
```swift
var lattice1 = try Lattice(Restaurant.self)
let lattice2 = try Lattice(Museum.self)

lattice1.attach(lattice: lattice2)

// Now lattice1 can query both Restaurant and Museum
let allPOIs = lattice1.objects(POI.self)  // Queries across both DBs
```

### Vector Search
```swift
// Single model vector search
let similar = lattice.objects(Document.self)
    .nearest(to: queryVector, on: \.embedding, limit: 10, distance: .cosine)

// With filtering
let filtered = lattice.objects(Document.self)
    .where { $0.category == "science" }
    .nearest(to: queryVector, on: \.embedding, limit: 10)

// Polymorphic vector search (federated across tables)
let similarPOIs = lattice.objects(POI.self)
    .nearest(to: locationVector, on: \.embedding, limit: 10)
```
